/*
 * This file is part of Co-Section.
 *
 * Copyright (C) 2020 Embodied Vision Group, Max Planck Institute for Intelligent Systems, Germany.
 * Developed by Michael Strecke <mstrecke at tue dot mpg dot de>.
 * For more information see <https://cosection.is.tue.mpg.de/>.
 * If you use this code, please cite the respective publication as
 * listed on the website.
 *
 * Co-Section is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Co-Section is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Co-Section.  If not, see <https://www.gnu.org/licenses/>.
 */
#pragma once

#include "EMFusion/core/data.h"
#include "CoSection/optim/data.h"
#include "EMFusion/core/EMFusion.h"
#include "CoSection/optim/OptSDF.h"
#include "CoSection/optim/ObjOptSDF.h"

namespace cosection {

/**
 * Class for processing RGB-D data with CoSection. Uses EMFusion as backend for
 * tracking and TSDF mapping and optimizes 3D models with hull and intersection
 * constraints.
 */
class CoSection : public emf::EMFusion {
public:
    /**
     * Constructor for CoSection class.
     *
     * @param _params Camera and algorithm paramerters for EM-Fusion
     * @param _cosecparams Co-Section algorithm parameters
     */
    CoSection ( const emf::Params& _params, const Params& _cosecparams );

    /**
     * Process a new frame (tracking and mapping of background and objects),
     * plus optimization of object and background models with hull and
     * intersection constraints.
     *
     * @param frame input frame
     */
    void processFrame ( const RGBD& frame );

    /**
     * Render the current model state from the current camera pose via
     * raycasting and display meshes generated by marching cubes and bounding
     * boxes of the objects.
     *
     * @param rendered the image to store the rendered output.
     * @param window pointer to an optional Viz3d window for mesh rendering.
     * @param show_slices whether to show optimized SDF slices in the 3D
     *                    visualization
     */
    void render ( cv::Mat& rendered, cv::viz::Viz3d* window = NULL,
                  bool show_slices = false );

    /**
     * Prepare for saving results to files.
     *
     * @param exp_vols whether to output volume data.
     */
    void setupOutput ( bool exp_vols );

    /**
     * Write results to a folder.
     *
     * @param path the path where results are stored (will be created and should
     *             not exist).
     */
    void writeResults ( const std::string& path );

    /**
     * Write runtimes for the different parts of the algorithm to the given
     * path.
     *
     * @param path the root path of the output directory
     */
    void writeTimes ( const std::string& path );

protected:
    /**
     * Update the poses of optimization volumes.
     */
    void updateOptimPoses ();

    /**
     * Check for new objects and initialize them.
     *
     * @param rgb input rgb image
     * @param matches the matches of object ids and Mask R-CNN segmentations
     *
     * @return number of detected instances by Mask R-CNN.
     */
    int initOrMatchObjs ( const cv::Mat& rgb,
                          std::map<int, cv::cuda::GpuMat>& matches );

    /**
     * Initialize new object volumes using unmatched masks.
     *
     * @param seg_gpus the Mask R-CNN detections
     * @param scores the class scores for the detections
     * @param unmatchedMasks the unmatched mask ids
     * @param matches the matched detections (will contain matches for new
     *                objects)
     * @param score_matches the scores for the matched detections  (will contain
     *                      matches for new objects)
     */
    void initObjsFromUnmatched (
        std::vector<cv::cuda::GpuMat>& seg_gpus,
        const std::vector<std::vector<double>>& scores,
        const std::set<int>& unmatchedMasks,
        std::map<int, cv::cuda::GpuMat>& matches,
        std::map<int, std::vector<double>>& score_matches );

    /**
     * Initialize new object volume.
     *
     * @param mask the object mask from Mask R-CNN
     * @param points the pointscloud in world coordinates
     * @param normals the normals associated with the pointcloud in world
     *                coordinates
     * @param pose the current camera pose
     *
     * @return class ID of new object, -1 if not initialized
     */
    int initNewObjVolume ( const cv::cuda::GpuMat& mask,
                           const cv::cuda::GpuMat& points,
                           const cv::cuda::GpuMat& normals,
                           const cv::Affine3f& pose );

    /**
     * Add point measurements to volumes.
     */
    void addMeasurements ();

    /**
     * Compute the hull constraint for all volumes.
     */
    void computeHull ();

    /**
     * Clear object foregrounds from other volumes.
     */
    void clearObjFg ();

    /**
     * Compute intersection of background with other objects.
     */
    void compBgInter ();

    /**
     * Optimize background volume.
     */
    void optimBg ();

    /**
     * Compute intersection constraint for the objects.
     */
    void compObjInter ();

    /**
     * Optimize object volumes.
     */
    void optimObjs ();

    /**
     * Write optimized meshes to files.
     *
     * @param p the path to write the results to.
     */
    void writeOptimMeshes ( const boost::filesystem::path& p );

    /**
     * Write optimization volumes to files.
     *
     * @param p the path to write the results to.
     */
    void writeOptimVols ( const boost::filesystem::path& p );

    /**
     * Write array of runtimes to file.
     *
     * @param times the array of runtimes for each frame
     * @param filename the name of the file to write the output to
     */
    void writeTimeArray ( const std::map<int, double>& times,
                          const std::string& filename );

    /**
     * Parameters for Co-Section (keyframe frequency and optimization
     * parameters).
     */
    Params cosecParams;

    /**
     * Set of new object ids in the current frame (for these, point measurements
     * were already added during initialization).
     */
    std::set<int> new_ids;

    /**
     * Normals from the input frame and their transformation in world
     * coordinates.
     */
    cv::cuda::GpuMat normals_in, normals_w;

    /** Background optimization volume. */
    OptSDF bg_opt;

    /** Object optimization volumes. */
    std::map<int, ObjOptSDF> obj_opt;

    // Variables for writing output
    std::map<int, std::map<int, cv::Mat>> frame_esdfs;
    std::map<int, std::map<int, cv::Mat>> frame_cs, frame_ws, frame_dHull,
        frame_dInter;

    std::map<int, double> bg_addMeas_runtimes;
    std::map<int, std::map<int, double>> obj_addMeas_runtimes;

    std::map<int, double> bg_compHull_runtimes;
    std::map<int, std::map<int, double>> obj_compHull_runtimes;

    std::map<int, double> bg_compInter_runtimes;
    std::map<int, std::map<int, double>> obj_compInter_runtimes;

    std::map<int, double> bg_optim_runtimes;
    std::map<int, std::map<int, double>> obj_optim_runtimes;

    std::map<int, cv::viz::Mesh> optim_meshes;
    std::map<int, cv::viz::Mesh> frame_optim_meshes;
    std::map<int, std::map<int, cv::viz::Mesh>> frame_obj_optim_meshes;

    std::map<int, std::map<int, cv::Mat>> frame_tsdfs;
    std::map<int, std::map<int, cv::Mat>> frame_fgProbs;
    std::map<int, std::map<int, std::pair<cv::Vec3i, float>>> frame_meta;
};

}
